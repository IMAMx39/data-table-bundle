[[{"l":"Introduction","p":["This bundle aims to streamline the creation process of the data tables in Symfony applications.","Despite the name, this bundle has no correlation with jQuery Data Tables."]},{"l":"Features","p":["Class based configuration with types similar to Symfony Forms","Triforce of the data tables — paginating, sorting and filtering","Personalization where the user decides the order and visibility of columns","Persistence to save user-applied pagination, sorting, filters and personalization","Customizable exporting, respecting personalization and applied filters","Theming of every part of the bundle","Data source agnostic with Doctrine ORM supported out of the box","Built-in integration with Symfony UX Turbo for asynchronicity"]}],[{"l":"Installation","p":["This bundle can be installed at any moment during a project’s lifecycle."]},{"l":"Download the bundle","p":["Use Composer to install the bundle:","If your application is using Symfony Flex, you can skip to installing the front-end dependencies."]},{"l":"Enable the bundle","p":["Enable the bundle by adding it to the config/bundles.php:"]},{"l":"Enable the Symfony UX integration","p":["This bundle provides front-end scripts created using the Stimulus JavaScript framework. To begin with, make sure your application uses the Symfony Stimulus Bridge.","Add @kreyu/data-table-bundle dependency to your package.json file:","Now, add @kreyu/data-table-bundle controllers to your assets/controllers.json file:"]},{"l":"Install front-end dependencies and rebuild","p":["The build process obviously depends on the configuration of your project."]}],[{"l":"Disclaimer","p":["This chapter explains how to quickly start using the bundle.","The articles are not representing every bundle feature to the fullest. Instead, they contain links to the reference section, where you can about each feature in depth."]},{"l":"Entities","p":["The articles assume, that the project uses Doctrine ORM and contains a Product entity:","For the sake of simplicity, the Doctrine mapping is skipped in the code block above."]},{"l":"Frontend","p":["The examples contain screenshots using the built-in Tabler UI Kit theme."]}],[{"l":"Creating data tables","p":["To create a data table, either:","use the trait to gain access to helpful methods;","inject data table factory and use it directly;","For the sake of simplicity, the documentation uses the trait method:","The trait gives access to three helper methods:","Method","Description","createDataTable","Creates data table using the type class.","createNamedDataTable","Creates data table using the type classes, but explicitly sets its name. Used in cases where the single page displays multiple data tables of the same type.","createDataTableBuilder","Creates a builder to describe the data table manually, without type classes. In most cases it is used for prototyping rather than actual usage.","Therefore, to create a data table, we need to create a data table type class."]},{"l":"Creating data table type classes","p":["The data table type classes work as a blueprint. A single type can be used to create as many data tables as needed - making them a nice, reusable piece of code. Those classes implement the DataTableTypeInterface, however, it is recommended to extend them from the AbstractDataTableType, which already implements the interface and provides some utilities.","Now, that the data table type class has been created, it can be used in the controller:","Running the code will result in an error:","The data table has no proxy query. You must provide it using either the data table factory or the builder \"setQuery()\" method.","This is because we haven't passed anything the data table can work on. Since we are using Doctrine ORM, the query builder should be passed as the \"query\" argument:","Running the code again will result in yet another error:","The data table has no configured columns. You must provide them using the builder \"addColumn()\" method.","The message is self-explanatory - the data table has no configured columns - it is time to add some of those."]}],[{"l":"Adding columns","p":["The data table builder object can be used to describe the columns used in the table. Similar to data tables, the columns are defined using the type classes."]},{"l":"Adding columns to the data table","p":["Let's start by adding a column for each field in the product entity:","The builder's addColumn() method accepts three arguments:","column name — which in most cases will represent a property path in the underlying entity;","column type — with a fully qualified class name;","column options — defined by the column type, used to configure the column;","For reference, see built-in column types."]},{"l":"Making the columns sortable","p":["The column types are configurable thanks to their options. The options can be passed as the third argument of the builder's addColumn() method. By default, columns are not sortable, because their sort option equals false. To change that, set the option to true:","Now that the data table contains some columns, let's render it to the user."]}],[{"l":"Rendering the table","p":["The data table is created, therefore, the next step is to render it to the user."]},{"l":"Creating data table view","p":["First, pass the data table view to the template. The data table view is somewhat a read-only representation of a table. It is created using the createView() method:","Now, create the missing template, and render the data table:","Voilà! ✨ The Twig helper function handles all the work and renders the data table."]},{"l":"Selecting a theme","p":["Unfortunately, the rendered data table looks awful. This is because the default theme is being used, which contains only the HTML necessary to base a custom themes on. To fix that, create bundle configuration file and specify desired theme:","The table is now rendered properly, using a Tabler UI Kit theme. For reference, see built-in themes.","The bundle does not contain the CSS libraries themselves! These must be installed and configured individually in the project."]},{"l":"Binding request to the data table","p":["Now, when trying to sort the data table by the ID column, nothing happens- this is because the data table has no clue the sorting occurred! To fix that, return back to the controller, and use the handy handleRequest() method:","Now the data table is fully interactive, by having access to the request object.","Speaking of interactivity, let's let the user filter the table."]}],[{"l":"Defining the filters","p":["One of the most important features of the data tables is the ability to filter the data. Similar to data tables and its columns, the filters are defined using the type classes."]},{"l":"Adding filters to the data table","p":["Let's start by adding a filter for each field in the product entity:","The builder's addFilter() method accepts three arguments:","filter name — which in most cases will represent a property path in the underlying entity;","filter type — with a fully qualified class name;","filter options — defined by the filter type, used to configure the filter;","For reference, see built-in filter types.","Being on the subject of filters, let's continue by enabling a global search feature."]}],[{"l":"Enabling global search","p":["Search filter input with the Tabler theme","While the filters may be useful in many cases, they are tied to a specific fields. Sometimes all the user needs is a single text input, to quickly search through multiple fields.","To handle that, there's a built-in special filter, which allows doing exactly that. The uniqueness of this filter shines in the way it is rendered - in the built-in themes, instead of showing up in the filter form, it gets displayed above, always visible, easily accessible."]},{"l":"Adding the search filter","p":["To start, define a filter of search type — its name doesn't really matter:","Trying to display the data table with this filter configuration will result in an error:","The required option \"handler\" is missing.","This is because the search filter type requires a handler option, which contains all the logic required for the data table search capabilities."]},{"l":"Writing the search handler","p":["The option accepts a callable, which gets an instance of query, and a search string as its arguments:","Tip: Move the search handler logic into repository to reduce the type class complexity.","Now that the data table has full filtration and search capabilities, let's focus on something that may be really important in some use cases — exporting the data."]}],[{"l":"Exporting the data","p":["Ability to export the data is crucial in some use cases. The exporters handle the exporting process. Similar to data tables and its columns and filters, exporters are defined using the type classes.","Export modal with the Tabler theme"]},{"l":"Prerequisites","p":["The bundle comes with exporter types using the PhpSpreadsheet. This library is not included as a bundle dependency, therefore, you have to make sure it is installed:"]},{"l":"Adding exporters to the data table","p":["To add exporter, use the builder's addExporter() method:","The builder's addExporter() method accepts three arguments:","exporter name;","exporter type — with a fully qualified class name;","exporter options — defined by the exporter type, used to configure the exporter;","For reference, see built-in exporter types."]},{"l":"Downloading the file","p":["To download an export file, use the export() method on the data table.","If you're using data tables in controllers, use it in combination with isExporting() method:"]}],[{"l":"Adding actions","p":["What is a list of products without the ability of creating and editing the records? In this bundle, there are two kinds of actions:","global action, displayed above the data table - e.g. \"Create new user\";","row action, displayed on each row, e.g. \"Edit\", \"Delete\";","Similar to data tables, columns and filters, actions are defined using the type classes."]},{"l":"Adding global actions","p":["Global action with the Tabler theme","Let's assume that the application has an app_product_create route for creating new products. The user should be able to click a \"Create new product\" button above the data table.","To add global action, use the builder's addAction() method:","The builder's addAction() method accepts three arguments:","action name;","action type — with a fully qualified class name;","action options — defined by the action type, used to configure the action;","For reference, see built-in action types."]},{"l":"Adding row actions","p":["Row actions with the built-in Tabler theme","Let's assume that the application has routes for showing product details, editing and deleting the product. Those actions cannot be global because they are bound to each row, and in fact, to a specific product (the routes require product identifier).","To handle this type of actions, there's a built-in action column type, which allows using the same action type classes as in their global definition.","Since there are no addAction() method, the actions are defined in the options. The action names are passed as the actions option array keys. Each entry requires:","a type option — same as the addAction() second argument;","a type_options option — same as the addAction() third argument;","There's one thing missing... a delete action! But let's say it is different because it requires a POST request to delete a product. In this case, the built-in form action type will handle it:","Now everything works fine - clicking on the delete actions sends a POST request, because the action is wrapped in a form configured to use the POST method."]},{"l":"Enabling action confirmation","p":["Clicking on the delete action immediately removes the products — in some cases it may be fine, but dangerous actions should be confirmable by the user.","Action confirmation modal with the Tabler theme","By default, actions are not confirmable, because their confirmation option equals false. To change that, set the option to true:","Now that the data table seems to be complete, let's focus on something really special — a personalization, where the user can decide which columns are visible, or even their order!"]}],[{"l":"Personalization","p":["Although the product table shown in the examples is tiny, imagine that it actually contains dozens of other columns — making it quickly unreadable! In addition, each user may prefer a different order of these columns. This is where the personalization functionality comes to the rescue, allowing you to freely show or hide the columns, and even determine their order."]},{"l":"Enabling the personalization feature","p":["The personalization feature is disabled for each data table by default. There are multiple ways to configure the personalization feature, but for now, let's do it globally. Navigate to the package configuration file (or create one if it doesn't exist) and change it like so:","The personalization feature may look really handy, but try refreshing the page after applying the personalization - it's gone! Now imagine configuring it on every request as the user - nightmare \uD83D\uDC7B This can be solved by enabling the persistence feature, which will save the personalization data (and even the applied pagination, sorting and filters if you wish!) between requests, per user."]}],[{"l":"Persisting applied data","p":["In complex applications, it can be very helpful to retain data such as applied personalization, filters, applied sorting or at least the currently displayed page. The bundle comes with the persistence feature, which can be freely configured for each feature individually.","Let's focus on persisting the applied personalization data first."]},{"l":"Prerequisites","p":["For a basic usage, we're assuming that the persistence data will be saved to a cache, and are saved individually per user. Therefore, make sure the Symfony Cache and Security components are installed and enabled. The bundle will automatically use them for persistence."]},{"l":"Enabling the persistence feature","p":["The personalization persistence feature is disabled for each data table by default. There are multiple ways to configure the persistence feature, but let's do it globally. Navigate to the package configuration file (or create one if it doesn't exist) and change it like so:","Assuming that the user is authenticated, apply the personalization data again, refresh the page... the applied personalization is still there!","This basic example barely scratches the surface of the persistence feature. You can also persist applied pagination (e.g. current page), sorting, filters, use different adapters (to, for example, save the data to the database, instead of cache), or even use different subject providers (to, for example, not rely on authenticated user, but on the request IP).","There's still one thing to walk through — let's translate the data table to multiple languages."]}],[{"l":"Internationalization","p":["Internationalization is the cornerstone of any complex application - regardless of whether only one language is initially planned, the safe solution generally seems to be to include all labels into translation files.","The data tables are supporting the Symfony Translation component out of the box. The built-in themes contains labels translated using the KreyuDataTable domain. Currently, there's two locales supported by the bundle:","Polish (pl)","English (en)"]},{"l":"Changing the built-in themes locale","p":["The bundle respects locale set in the framework. See official documentation on how to configure the translation component."]},{"l":"Overwriting the built-in translations","p":["The bundle (and its themes) uses the KreyuDataTable translation domain. To overwrite the translations inside this domain, see official documentation on how to overwrite a third-party bundle translations."]},{"l":"Changing the data table type translation domain","p":["There are multiple labels that can be translated — for example, column headers or filter names. By default, every label is translated using the messages domain. Similar to Symfony Forms component, to change the default translation domain of a data table, change the default value of translation_domain option in the type:"]},{"l":"Changing the column type translation domain","p":["The column types are little different from the data table types — instead of translation_domain option, these contain two:","header_translation_domain- used to translate the column headers, e.g. \"Created At\" into \"Creation date\" — by default, inherits the domain from the data table itself;","value_translation_domain- used to translate the column values, for example, in case of boolean column type, it translates the \"Yes\" and \"No\" strings — it does not inherit the domain from the data table, but uses the KreyuDataTable.","There may be some cases, where a single column may use a different translation domain. Let's assume that the dates translation domain contains strings related with dates, therefore, the createdAt column should use the dates domain:","The internationalization chapter ends the basic usage section of the documentation. Now, continue to summary to see what else may be important to read from now to configure the data tables even further \uD83D\uDE80"]}],[{"l":"Summary","p":["The basic usage section went through every available feature in a very basic manner — only explaining the absolute minimum required to configure a data table. It may suit some cases, but this bundle is much, much more extensive - read through the rest of the documentation to get better understanding of how things work.","The recommended sections to continue reading:","Type classes- to understand how the types and their extensions work;"]}],[{"l":"Pagination","p":["The data tables can be paginated, which is crucial when working with extensive data sources."]},{"l":"Toggling the feature","p":["By default, the pagination feature is enabled for every data table.","You can change this setting globally using the package configuration file, or use pagination_enabled option:","By default, every page contains 25 records. Built-in themes display pagination controls only when the data table contains more than one page. Also, remember that you can change the default pagination data, reducing the per-page limit."]},{"l":"Configuring the feature persistence","p":["By default, the pagination feature persistence is disabled for every data table.","You can configure the persistence globally using the package configuration file, or its related options:"]},{"l":"Configuring default pagination","p":["The default pagination data can be overridden using the data table builder's setDefaultPaginationData() method:"]}],[{"l":"Sorting","p":["The data tables can be sorted, which is helpful when working with sortable data sources."]},{"l":"Toggling the feature","p":["By default, the sorting feature is enabled for every data table.","You can change this setting globally using the package configuration file, or use sorting_enabled option:","By default, columns are not sortable."]},{"l":"Making the columns sortable","p":["To make any column sortable, use its sort option:","The bundle will use the column name as the path to perform sorting on. However, if the path is different from the column name (for example, to display \"category\", but sort by the \"category name\"), provide it using the same sort option:"]},{"l":"Configuring the feature persistence","p":["By default, the sorting feature persistence is disabled for every data table.","You can configure the persistence globally using the package configuration file, or its related options:"]},{"l":"Configuring default sorting","p":["The default sorting data can be overridden using the data table builder's setDefaultSortingData() method:","Although, with built-in themes, the user can perform sorting only by a single column."]}],[{"l":"Filtering","p":["The data tables can be filtered, with use of the filters."]},{"l":"Toggling the feature","p":["By default, the filtration feature is enabled for every data table.","You can change this setting globally using the package configuration file, or use filtration_enabled option:"]},{"l":"Configuring the feature persistence","p":["By default, the filtration feature persistence is disabled for every data table.","You can configure the persistence globally using the package configuration file, or its related options:"]},{"l":"Adding the filters","p":["To add a filter, use the addFilter() method on the data table builder:","The builder's addFilter() method accepts three arguments:","filter name — which in most cases will represent a property path in the underlying entity;","filter type — with a fully qualified class name;","filter options — defined by the filter type, used to configure the filter;","For reference, see built-in filter types."]},{"l":"Specifying the query path","p":["The bundle will use the filter name as the path to perform filtration on. However, if the path is different from the column name, provide it using the query_path option:","For reference, see built-in filter types."]},{"l":"Filter operators","p":["Each filter can support multiple operators, such as \"equals\", \"contains\", \"starts with\", etc. Optionally, the filtration form can display the operator selector, letting the user select a desired filtration method."]},{"l":"Default operator","p":["By default, each filter defines an array of supported operators. Those operators are then available to select by the user in the form. If operator selector is not visible, then the first choice is used.","In case of the string filter, the default operator is EQUALS, because it is first in the supported operators array, stored in the operator_options.choices option. To change the default operator to CONTAINS, set the choices option to an array containing it as the first entry:"]},{"l":"Displaying operator selector","p":["By default, the operator selector is not visible, because the operator_options.visible equals false. To change that, set the option to true:","Of course, it is possible to define both options at once, restricting operators visible to the user:"]},{"l":"Configuring default filtration","p":["The default filtration data can be overridden using the data table builder's setDefaultFiltrationData() method:"]}],[{"l":"Personalization","p":["Personalization with the Tabler theme","The data tables can be personalized, which can be helpful when working with many columns, by giving the user ability to:","set the order of the columns;","show or hide specific columns;"]},{"l":"Prerequisites","p":["To begin with, make sure the Symfony UX integration is enabled. Then, enable the personalization controller:"]},{"l":"Toggling the feature","p":["By default, the personalization feature is disabled for every data table.","You can change this setting globally using the package configuration file, or use personalization_enabled option:"]},{"l":"Configuring the feature persistence","p":["By default, the personalization feature persistence is disabled for every data table.","You can configure the persistence globally using the package configuration file, or its related options:"]},{"l":"Configuring default pagination","p":["The default personalization data can be overridden using the data table builder's setDefaultPersonalizationData() method:"]}],[{"l":"Exporting","p":["The data tables can be exported, with use of the exporters, defined using the type classes.","Export modal with the Tabler theme"]},{"l":"Prerequisites","p":["The built-in exporter types require PhpSpreadsheet. This library is not included as a bundle dependency, therefore, you have to make sure it is installed:"]},{"l":"Toggling the feature","p":["By default, the exporting feature is enabled for every data table.","You can change this setting globally using the package configuration file, or use exporting_enabled option:"]},{"l":"Adding the exporters","p":["To add exporter, use the builder's addExporter() method on the data table builder:","The builder's addExporter() method accepts three arguments:","exporter name;","exporter type — with a fully qualified class name;","exporter options — defined by the exporter type, used to configure the exporter;","For reference, see built-in exporter types."]},{"l":"Adding multiple exporters of the same type","p":["Let's think of a scenario where the user wants to export the data table to CSV format, but there's a catch — it must be possible to export as either comma or semicolon separated file."]},{"l":"Downloading the file","p":["To download an export file, use the export() method on the data table.","If you're using data tables in controllers, use it in combination with isExporting() method:"]}],[{"l":"Global search","p":["Search filter input with the Tabler theme","While the filters may be useful in many cases, they are tied to a specific fields. Sometimes all the user needs is a single text input, to quickly search through multiple fields.","To handle that, there's a built-in special filter, which allows doing exactly that. The uniqueness of this filter shines in the way it is rendered - in the built-in themes, instead of showing up in the filter form, it gets displayed above, always visible, easily accessible."]},{"l":"Adding the search filter","p":["To start, define a filter of search type — its name doesn't really matter:","Trying to display the data table with this filter configuration will result in an error:","The required option \"handler\" is missing.","This is because the search filter type requires a handler option, which contains all the logic required for the data table search capabilities."]},{"l":"Writing the search handler","p":["The option accepts a callable, which gets an instance of query, and a search string as its arguments:","Tip: Move the search handler logic into repository to reduce the type class complexity."]}],[{"l":"Persistence","p":["This bundle provides persistence feature, ready to use with data table sorting, pagination, filtration and personalization."]},{"l":"Persistence adapters","p":["Adapters are classes that allow writing (to) and reading (from) the persistent data source."]},{"l":"Built-in adapters","p":["By default, there's only one adapter integrating the Symfony Cache. It accepts two arguments in the constructor:","a cache implementing Symfony's CacheInterface","prefix string used to differentiate different data sets, e.g. filtration persistence uses filtration prefix","In service container, it is registered as an abstract service:","The adapters are then created based on the abstract definition:"]},{"l":"Creating custom adapters","p":["To create a custom adapter, create a class that implements PersistenceAdapterInterface:","The recommended namespace for the persistence adapters is App\\DataTable\\Persistence.","...and register it in the container as an abstract service:","Now, create as many adapters as you need, based on the abstract definition. For example, let's create an adapter for sorting feature, prefixed with \"sorting\".","The data tables can now be configured to use the new persistence adapter for the personalization feature:"]},{"l":"Persistence subjects","p":["Persistence subject can be any object that implements PersistenceSubjectInterface.","The value returned in the getDataTablePersistenceIdentifier() is used in persistence adapters to associate persistent data with the subject."]},{"l":"Persistence subject providers","p":["Persistence subject providers are classes that allow retrieving the persistence subjects. Those classes contain provide method, that should return the subject, or throw an PersistenceSubjectNotFoundException."]},{"l":"Built-in subject providers","p":["By default, there's only one provider, integrating with Symfony token storage, to retrieve currently logged-in user. The token storage persistence subject provider uses the UserInterface's getUserIdentifier() method is used as the persistence identifier. If you wish to override this behavior without modifying the getUserIdentifier() method, implement the PersistenceSubjectInterface on the User entity:"]},{"l":"Creating custom subject providers","p":["To create a custom subject provider, create a class that implements PersistenceSubjectProviderInterface:","Subject providers must be registered as services and tagged with the kreyu_data_table.persistence.subject_provider tag. If you're using the default services.yaml configuration, this is already done for you, thanks to autoconfiguration.","When using the default container configuration, that provider should be ready to use. If not, consider tagging this class as kreyu_data_table.persistence.subject_provider:"]}],[{"l":"Theming","p":["Every HTML part of this bundle can be customized using Twig themes."]},{"l":"Built-in themes","p":["The following themes are natively available in the bundle:","@KreyuDataTable/themes/bootstrap_5.html.twig- integrates Bootstrap 5;","@KreyuDataTable/themes/tabler.html.twig- integrates Tabler UI Kit;","@KreyuDataTable/themes/base.html.twig- base HTML template;","By default, the @KreyuDataTable/themes/base.html.twig theme is used.","The default template provides minimal HTML required to properly display the data table."]},{"l":"Selecting a theme","p":["To select a theme, provide which one to use in the bundle configuration file. For example, in order to use the Bootstrap 5 theme:","For more information, see \"themes\" option configuration reference."]},{"l":"Customizing existing theme","p":["To customize existing theme, you can either:","create a template that extends one of the built-in themes;","create a template that overrides the built-in theme;","create a template from scratch;","Because themes configuration option accepts an array of themes, you can provide your own theme with only a fraction of Twig blocks, using the built-in themes as a fallback, for example:","For more information, see \"themes\" option configuration reference."]}],[{"l":"Proxy queries","p":["This bundle is data source agnostic, meaning it is not tied to any specific ORM, such as Doctrine ORM. This is accomplished thanks to proxy queries, which work as an adapter for the specific data source.","For example, if you want to display a list of products from the database, and your application uses Doctrine ORM, then you'd want to use the built-in DoctrineOrmProxyQuery. If your data comes from another source (from an array, from CSV, etc.), then you can create a custom proxy query class."]},{"l":"Creating custom proxy query","p":["To create a custom proxy query, create a class that implements ProxyQueryInterface:","The recommended namespace for the proxy queries is App\\DataTable\\Query.","Now you can use the custom proxy query when creating the data tables:"]},{"l":"Creating proxy query factory","p":["When using the data table factory, you can pass either the custom proxy query class, or just the data you want to operate on. For example, if you pass Doctrine ORM's QueryBuilder class, it will be automatically converted to the DoctrineOrmProxyQuery object:","If you try to do the same with the custom proxy query, it will result in an error:","Unable to create ProxyQuery for given data","In the background, the ChainProxyQueryFactory iterates through registered proxy query factories, and returns the first successfully created proxy query. The error occurs because there is no factory to create the custom type.","To create a proxy query factory, create a class that implements the ProxyQueryFactoryInterface:","If the custom proxy query does not support a specific data class, the factory have to throw an UnexpectedTypeException, so the chain proxy query factory will know to skip that factory and check other ones.","Proxy query factories must be registered as services and tagged with the kreyu_data_table.proxy_query.factory tag. If you're using the default services.yaml configuration, this is already done for you, thanks to autoconfiguration.","In above examples, now it would be possible to pass the array directly as the \"query\" argument:"]}],[{"l":"Request handlers","p":["The data tables by default have no clue about the requests. To solve this problem, a request can be handled by the data table using the handleRequest() method. This means an underlying request handler will be called, extracting the required data from the request, and calling methods such as sort() or paginate() on the data table."]},{"l":"Built-in request handlers","p":["This bundle comes with HttpFoundationRequestHandler, which supports the request object common for the Symfony applications:"]},{"l":"Creating request handlers","p":["To create a request handler, create a class that implements RequestHandlerInterface:","The recommended namespace for the request handlers is App\\DataTable\\Request.","You can apply this request handler globally using the configuration file, or use request_handler option:"]}],[{"l":"Type classes","p":["Multiple parts of the bundle, such as columns, filters etc. are described using the type classes. Their purpose and method of definition is very similar to the Symfony Form Types, which means knowing how these work really helps in understanding most of the bundle.","Following parts of the bundle are defined using the type classes:","data tables","columns","filters","actions","exporters"]},{"l":"Creating custom type classes","p":["Abstract class","AbstractActionType","AbstractColumnType","AbstractDataTableType","AbstractExporterType","AbstractFilterType","Actions","ActionTypeInterface","App\\DataTable\\Action\\Type","App\\DataTable\\Column\\Type","App\\DataTable\\Exporter\\Type","App\\DataTable\\Filter\\Type","App\\DataTable\\Type","Columns","ColumnTypeInterface","Component","Custom type classes are automatically registered as a service.","Data tables","DataTableTypeInterface","Every type in the bundle is registered as a tagged service:","Exporters","ExporterTypeInterface","Filters","FilterTypeInterface","Interface","kreyu_data_table.action.type","kreyu_data_table.column.type","kreyu_data_table.exporter.type","kreyu_data_table.filter.type","kreyu_data_table.type","Namespace","The recommended namespaces to put the types are as follows:","The type classes work as a blueprint that defines a configuration how its feature should work. They implement their own, feature-specific interface. However, it is better to extend from the abstract classes, which already implement the interface and provide some utilities.","Type tag"]},{"l":"Type inheritance","p":["For example, let's think of a column type that represents a phone number. In theory, it should extend the existing text column type, only adding a phone number oriented formatting. In practice, the type's class should not extend the text type class directly:","This is invalid- do NOT use PHP class inheritance!","Instead, it should return the fully qualified class name of the parent type in the getParent() method:","This is valid- extend abstract type and return parent's class name!","The difference is all about the extensions. Considering the example above, while using the PHP inheritance, a type extensions defined for the text column type won't be applied to the phone column type."]},{"l":"Type configuration options","p":["Each type class contains its own set of options, that can be used to configure the type according to a specific need. Those options can be defined in any type class configureOptions() method, by using the OptionsResolver component:","Additionally, options are inherited from the type specified in the getParent() method:"]},{"l":"Defining the type extensions","p":["Abstract class","AbstractColumnTypeExtension","AbstractDataTableTypeExtension","AbstractExporterTypeExtension","AbstractFilterTypeExtension","Actions","ActionTypeExtensionInterface","Columns","ColumnTypeExtensionInterface","Component","Data tables","DataTableTypeExtensionInterface","Exporters","ExporterTypeExtensionInterface","Filters","FilterTypeExtensionInterface","Interface","The type extensions allow to easily extend existing types. Those classes contain methods similar as their corresponding feature type classes. They implement their own, feature-specific interface. For easier usage, there's also an abstract classes, which already implements the interface and provides some utilities."]},{"l":"Setting the types to extend","p":["Each type extension class have to define a list of types that it extends, using the getExtendedTypes() method. For example, if you wish to create an extension for a built-in text column type, consider following configuration:","To apply extension to every type in the system, use the base type of each part of the bundle. For example, in case of the column types:","For reference, a list of each feature base type class:","Component","Base type class","Data tables","DataTableType","Columns","ColumnType","Filters","FilterType","Actions","ActionType","Exporters","ExporterType"]},{"l":"Setting the extension order","p":["Every type extension in the bundle is registered as a tagged service:","Component","Service tag","Data tables","kreyu_data_table.type_extension","Columns","kreyu_data_table.column.type_extension","Filters","kreyu_data_table.filter.type_extension","Actions","kreyu_data_table.action.type_extension","Exporters","kreyu_data_table.exporter.type_extension","Tagged services can be prioritized using the priority attribute to define the order the extensions will be loaded:","In the example above, the ExtensionB will be applied before the Extension A, because it has higher priority. Without the priority specified, the extensions would be applied in the order they are registered."]},{"l":"Resolving the types","p":["Actions","Breaking it down into smaller pieces, first, the type's parent method is called:","Columns","Component","Data tables","Each component that supports the type classes, contain its \"resolved\" counterpart:","Exporters","Filters","Last but not least, there's the extensions:","Next comes the inner type itself:","Resolved type class","Resolved type classes contain similar methods as a non-resolved types. To understand how resolving process works, take a look at implementation of the resolved data table type's buildDataTable() method:","ResolvedActionType","ResolvedColumnType","ResolvedDataTableType","ResolvedExporterType","ResolvedFilterType","The inner type is an instance of non-resolved type, provided with the FQCN when defining the data table. It is very important to understand, that this method is called after the parent one, but before any extension.","The parent is an instance of already resolved type. It is based on the FQCN provided in the getParent() method.","This is why defining an order of extensions may be very important in some cases. Same flow applies to every resolved type class and most of its methods in the bundle.","Type classes support inheritance and extensions, therefore they must be resolved before they can be used in the application. The resolved type classes has direct access to an instance of the parent type (also resolved), as well as the extensions to apply."]},{"l":"Accessing the type registry","p":["ActionRegistry","Actions","ColumnRegistry","Columns","Component","create resolved types using the ResolvedTypeFactoryInterface;","Data tables","DataTableRegistry","Each component that supports the type classes contains its own registry:","ExporterRegistry","Exporters","FilterRegistry","Filters","hold instances of the registered types and extensions;","In reality, the purpose of the registry is to:","Resolved type class","The registries are the classes that stores all the types and extensions registered in the system. Those classes are used to easily retrieve a resolved types, while only requiring a fully qualified class name of the desired type."]}],[{"l":"Integration with Symfony UX Turbo","p":["Symfony UX Turbo is a Symfony bundle integrating the Hotwire Turbo library in Symfony applications. It allows having the same user experience as with Single Page Apps but without having to write a single line of JavaScript!","This bundle provides integration that works out-of-the-box."]},{"l":"The magic part","p":["To begin with, make sure your application uses the Symfony UX Turbo. The next step is... voilà! ✨ You don't have to configure anything extra, your data tables automatically work asynchronously! The magic comes from the base template, which wraps the whole table in the turbo-frame tag:","This ensures every data table is wrapped in its own frame, making them work asynchronously.","This integration also works on other built-in templates because they all extend the base one. If you're making a data table theme from scratch, make sure the table is wrapped in the Turbo frame, as shown above.","For more information, see official documentation about the Turbo frames."]}],[{"l":"Troubleshooting","p":["This section covers common problems and how to fix them."]},{"l":"Sorting is enabled but columns are not sortable","p":["Enabling the sorting feature for the data table does not mean that any column will be sortable by itself. By default, columns are not sortable. To make a column sortable, use its sort option.","For more information, consider reading:","Basic Usage > Adding columns > Binding request to the data table","Features > Sorting > Making the columns sortable"]},{"l":"Data table features are refreshing the page but not working","p":["If, for example, a data table is rendered properly, but:","clicking on pagination,","changing sort order,","applying filters,","etc.","refreshes the page but does nothing else, make sure you handled the request using the handleRequest() method:","For more information, consider reading:","Basic Usage > Rendering the table > Binding request to the data table","Features > Request handlers"]},{"i":"the-n1-problem","l":"The N+1 problem","p":["When using Doctrine ORM, if your data table contains columns with data from relationship:","...then, remember to join and select the association to prevent N+1 queries:"]},{"i":"the-n1-problem-with-unused-one-to-one-relations","l":"The N+1 problem with unused one-to-one relations","p":["If your entity contains a one-to-one relationship that is not used in the data table, the additional queries will be generated anyway, because the Doctrine Paginator is always loading them. To prevent that, add a hint to force a partial load:"]},{"i":"persistence-cache-tag-contains-reserved-characters-error","l":"Persistence \"cache tag contains reserved characters\" error","p":["When using the default configuration, after enabling the persistence for any feature, it may result in the error:","Cache tag \"kreyu_data_table_persistence_user@example.com\" contains reserved characters \"()/\\@:\".","By default, the bundle is using a cache as a persistence storage, and currently logged-in user as a persistence subject. To identify which data belongs to which user, the persistence subject must return a unique identifier. To retrieve a unique identifier of a user without additional configuration, a UserInterface::getUserIdentifier() method is used. Unfortunately, in some applications, it may return something with a reserved character — in case of above error, an email address \"user@example.com\".","To prevent that, implement a PersistenceSubjectInterface interface on the User object and manually return the unique identifier:","For more information, consider reading:","Features > Persistence > Built-in subject providers"]}],[{"l":"Available column types","p":["Actions","Base columns","Boolean","Collection","Column","Date and time columns","DatePeriod","DateTime","Form","Link","Number","Special columns","Template","Text","Text columns","The following column types are natively available in the bundle:"]}],[{"l":"Available filter types","p":["The following filter types are natively available in the bundle:","Doctrine ORM filters","String","Numeric","Boolean","Date","DateTime","Entity","Callback","Base filters","Filter"]}],[{"l":"Available action types","p":["The following action types are natively available in the bundle:","Common actions","Link","Button","Form","Base actions","Action"]}],[{"l":"Available exporter types","p":["The following exporter types are natively available in the bundle:","PhpSpreadsheet exporters","Csv","Xls","Xlsx","Html","Ods","PhpSpreadsheet","Base exporters","Exporter"]}],[{"l":"Configuration","p":["This bundle can be configured using the config/packages/kreyu_data_table.yaml file."]},{"l":"Themes","p":["You can define which Twig theme to use with the data tables using the themes node. By default, the base theme is used. Because themes are built using Twig blocks, the bundle iterates through given themes, until it finds the desired block, using the first one it finds.","For more information about theming, see theming reference."]},{"l":"Data table builder defaults","p":["You can specify default values applied to all the data tables using the defaults node. Those are used as a default builder values, unless the user enters some option value manually, either by passing it as a data table option, or by using the data table builder directly.","The default configuration is loaded by the DefaultConfigurationDataTableTypeExtension, that extends every data table type class with DataTableType specified as a parent.","The given values represent the default ones, unless specifically stated otherwise:","The default cache persistence adapters are provided only if the Symfony Cache component is installed. If the component is not installed, then the default value equals null, meaning you'll have to specify an adapter manually if you wish to use the persistence.","The persistence subject providers are provided only if the Symfony Security component is installed. If the component is not installed, then the default value equals null, meaning you'll have to specify a subject provider manually if you wish to use the persistence."]}],[{"l":"Twig"},{"l":"Functions","p":["Even though the helper functions simply renders a template block of a specific part of the data table, they are very useful because they take use the theme configured in bundle."]},{"l":"data_table","p":["With arguments: data_table(data_table_view, variables)","Renders the HTML of a complete data table, with action bar, filtration, pagination, etc.","You will mostly use this helper for prototyping or if you use custom theme. If you need more flexibility in rendering the data table, you should use the other helpers to render individual parts of the data table instead."]},{"l":"data_table_form_aware","p":["With arguments: data_table_form_aware(data_table_view, form_view, data_table_variables, form_variables)","Renders the HTML of the data table with table part wrapped in the given form."]},{"l":"data_table_table","p":["With arguments: data_table_table(data_table_view, variables)","Renders the HTML of the data table."]},{"l":"data_table_action_bar","p":["With arguments: data_table_action_bar(data_table_view, variables)","Renders the HTML of the data table action bar, which includes filtration, exporting and personalization features."]},{"l":"data_table_header_row","p":["With arguments: data_table_header_row(header_row_view, variables)","Renders the header row of the data table."]},{"l":"data_table_value_row","p":["With arguments: data_table_value_row(value_row_view, variables)","Renders the value row of the data table."]},{"l":"data_table_column_label","p":["With arguments: data_table_column_label(column_view, variables)","Renders the label of the column. This takes care of all the label translation logic under the hood."]},{"l":"data_table_column_header","p":["With arguments: data_table_column_header(column_view, variables)","Renders the header of the column. Internally, this does the same as data_table_column_label() method, but additionally handles the sorting feature."]},{"l":"data_table_column_value","p":["With arguments: data_table_column_value(column_view, variables)","Renders the value of the column. It handles all the required logic to extract value from the row data based on the column configuration (e.g. to display formatted name of the Project entity)."]},{"l":"data_table_filters_form","p":["With arguments: data_table_filters_form(form)","Renders the filters form. Accepts both the FormInterface and FormView. If given value is instance of FormInterface, the createView() method will be called."]},{"l":"data_table_personalization_form","p":["With arguments: data_table_personalization_form(form)","Renders the personalization form. Accepts both the FormInterface and FormView. If given value is instance of FormInterface, the createView() method will be called."]},{"l":"data_table_export_form","p":["With arguments: data_table_export_form(form)","Renders the export form. Accepts both the FormInterface and FormView. If given value is instance of FormInterface, the createView() method will be called."]},{"l":"data_table_pagination","p":["With arguments: data_table_pagination(pagination_view, variables)","Renders the pagination controls.","Additionally, accepts the data table view as a first argument. In this case, the pagination view is extracted from the data table view \"pagination\" variable."]},{"l":"Variables","p":["Certain types may define even more variables, and some variables here only really apply to certain types. To know the exact variables available for each type, check out the code of the templates used by your data table theme."]},{"l":"Data table variables","p":["A list of actions defined for the data table.","A list of exporters defined for the data table.","A list of filters defined for the data table.","A list of instances of value rows views.","actions","An instance of filtration data, that contains applied filters values.","An instance of headers row view without personalization applied.","An instance of headers row view.","An instance of pagination.","An instance of sorting data, that contains applied sorting values.","column_count","export_form","export_parameter_name","exporters","exporting_enabled","filters","filtration_data","filtration_enabled","filtration_form","filtration_parameter_name","has_active_filters","header_row","Holds an instance of the export form view.","Holds an instance of the filtration form view.","Holds an instance of the personalization form view.","Holds count of the columns, respecting the personalization.","If at least one filter is active, this value will equal true.","If true, the exporting feature is enabled.","If true, the filtration feature is enabled.","If true, the pagination feature is enabled.","If true, the personalization feature is enabled.","If true, the sorting feature is enabled.","name","Name of the data table.","Name of the parameter that holds the current page number.","Name of the parameter that holds the export form data.","Name of the parameter that holds the filtration form data.","Name of the parameter that holds the pagination per page limit.","Name of the parameter that holds the personalization form data.","Name of the parameter that holds the sorting data array (e.g. [{sort_parameter_name}][field], [{sort_parameter_name}][direction]).","non_personalized_header_row","page_parameter_name","pagination","pagination_enabled","Parameters used in title translation.","per_page_parameter_name","personalization_enabled","personalization_form","personalization_parameter_name","sort_parameter_name","sorting_data","sorting_enabled","The following variables are common to every data table type:","title","Title of the data table","title_translation_parameters","Translation domain used in translatable strings in the data table. If false, the translation is disabled.","translation_domain","Usage","value_rows","Variable"]},{"l":"Column header variables","p":["A list of block prefixes respecting the type inheritance.","An array of attributes used in rendering the column header.","An array of export options, including label and translation_domain options. Equals false if the column is not exportable.","An instance of column view.","An instance of data table view.","An instance of header row that the column belongs to.","attr","block_prefixes","column","data_table","Determines whether the column is currently being sorted.","Direction in which the column is currently being sorted.","export","label","Label that will be used when rendering the column header.","name","Name of the column.","Name of the parameter that holds the sorting data array (e.g. [{sort_parameter_name}][field], [{sort_parameter_name}][direction]).","Parameters used when translating the header translatable values (e.g. label).","row","Sort field used by the sortable behavior. If false, the sorting is disabled for the column.","sort_direction","sort_field","sort_parameter_name","sorted","The following variables are common to every column type header:","Translation domain used when translating the column translatable values. If false, the translation is disabled.","translation_domain","translation_parameters","Usage","Variable"]},{"l":"Column value variables","p":["A list of block prefixes respecting the type inheritance.","An array of attributes used in rendering the column value.","An array of export options, including data, value, label and translation_domain options. Equals false if the column is not exportable.","An instance of data table view.","An instance of value row that the column belongs to.","attr","block_prefixes","data","data_table","export","Holds the norm data of a column.","Holds the string representation of a column value.","Parameters used when translating the translatable values.","row","The following variables are common to every column type value:","Translation domain used when translating the column translatable values. If false, the translation is disabled.","translation_domain","translation_parameters","Usage","value","Variable"]},{"l":"Filter variables","p":["Array of options passed to the form type defined in the field_type.","Array of options passed to the form type defined in the operator_type.","data","Field name used in the query (e.g. in DQL, like product.name)","field_options","field_type","Form field name of the column.","form_name","FQCN of the form field type used to render the filter control.","FQCN of the form field type used to render the operator control.","Holds the norm data of a filter.","Holds the string representation of a filter value.","label","Label that will be used when rendering the column header.","label_translation_parameters","name","Name of the filter.","operator_options","operator_type","Parameters used when translating the label option.","query_path","The following variables are common to every filter type:","Translation domain used when translating the column translatable values. If false, the translation is disabled.","translation_domain","Usage","value","Variable"]},{"l":"Action variables","p":["A list of block prefixes respecting the type inheritance.","An array of action confirmation options. If false, action is not confirmable.","An array of attributes used in rendering the action icon.","An array of attributes used in rendering the action.","An instance of data table view.","attr","Behind the scenes, these variables are made available to the DataTableView, ColumnView and FilterView objects of your data table when the DataTable component calls buildView(). To see what \"view\" variables a particular type has, find the source code for the used type class and look for the buildView() method.","block_prefixes","confirmation","data_table","icon_attr","label","name","Name of the action.","Parameters used when translating the action translatable values (e.g. label).","The following variables are common to every action type:","Translation domain used when translating the action translatable values. If false, the translation is disabled.","translation_domain","translation_parameters","Usage","Variable"]}]]